{"ID":"20240423170139-cxrklxr","Spec":"1","Type":"NodeDocument","Properties":{"icon":"spring.png","id":"20240423170139-cxrklxr","title":"文档：SpEL","type":"doc","updated":"20240423170424"},"Children":[{"ID":"20240423170424-mnkby1c","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240423170424-mnkby1c","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"8. Spring Expression Language (SpEL)"}]},{"ID":"20240423170424-wuxo8t3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240423170424-wuxo8t3","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"8.1 Introduction"}]},{"ID":"20240423170424-3i0c1jy","Type":"NodeParagraph","Properties":{"id":"20240423170424-3i0c1jy","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The Spring Expression Language (SpEL for short) is a powerful expression language that supports querying and manipulating an object graph at runtime. The language syntax is similar to Unified EL but offers additional features, most notably method invocation and basic string templating functionality."}]},{"ID":"20240423170424-lj7t0rp","Type":"NodeParagraph","Properties":{"id":"20240423170424-lj7t0rp","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"While there are several other Java expression languages available, OGNL, MVEL, and JBoss EL, to name a few, the Spring Expression Language was created to provide the Spring community with a single well supported expression language that can be used across all the products in the Spring portfolio. Its language features are driven by the requirements of the projects in the Spring portfolio, including tooling requirements for code completion support within the eclipse based SpringSource Tool Suite. That said, SpEL is based on a technology agnostic API allowing other expression language implementations to be integrated should the need arise."}]},{"ID":"20240423170424-m9cx8lg","Type":"NodeParagraph","Properties":{"id":"20240423170424-m9cx8lg","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"While SpEL serves as the foundation for expression evaluation within the Spring portfolio, it is not directly tied to Spring and can be used independently. In order to be self contained, many of the examples in this chapter use SpEL as if it were an independent expression language. This requires creating a few bootstrapping infrastructure classes such as the parser. Most Spring users will not need to deal with this infrastructure and will instead only author expression strings for evaluation. An example of this typical use is the integration of SpEL into creating XML or annotated based bean definitions as shown in the section "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-beandef","TextMarkATitle":"8.4 Expression support for defining bean definitions","TextMarkTextContent":"Expression support for defining bean definitions."}]},{"ID":"20240423170424-l6ymr22","Type":"NodeParagraph","Properties":{"id":"20240423170424-l6ymr22","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"This chapter covers the features of the expression language, its API, and its language syntax. In several places an Inventor and Inventor's Society class are used as the target objects for expression evaluation. These class declarations and the data used to populate them are listed at the end of the chapter."}]},{"ID":"20240423170424-h4f58zs","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240423170424-h4f58zs","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"8.2 Feature Overview"}]},{"ID":"20240423170424-jdd03e3","Type":"NodeParagraph","Properties":{"id":"20240423170424-jdd03e3","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The expression language supports the following functionality"}]},{"ID":"20240423170424-c5q51m0","Type":"NodeList","ListData":{},"Properties":{"id":"20240423170424-c5q51m0","updated":"20240423170425"},"Children":[{"ID":"20240423170424-nylokzg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-nylokzg","updated":"20240423170424"},"Children":[{"ID":"20240423170424-jojvoie","Type":"NodeParagraph","Properties":{"id":"20240423170424-jojvoie","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Literal expressions"}]}]},{"ID":"20240423170424-rhwrjh3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-rhwrjh3","updated":"20240423170424"},"Children":[{"ID":"20240423170424-7pxtae4","Type":"NodeParagraph","Properties":{"id":"20240423170424-7pxtae4","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Boolean and relational operators"}]}]},{"ID":"20240423170424-53drhbr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-53drhbr","updated":"20240423170424"},"Children":[{"ID":"20240423170424-rra8mc1","Type":"NodeParagraph","Properties":{"id":"20240423170424-rra8mc1","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Regular expressions"}]}]},{"ID":"20240423170424-9ofh1yj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-9ofh1yj","updated":"20240423170424"},"Children":[{"ID":"20240423170424-cmc429f","Type":"NodeParagraph","Properties":{"id":"20240423170424-cmc429f","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Class expressions"}]}]},{"ID":"20240423170424-x95x6gz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-x95x6gz","updated":"20240423170424"},"Children":[{"ID":"20240423170424-c1d40sv","Type":"NodeParagraph","Properties":{"id":"20240423170424-c1d40sv","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Accessing properties, arrays, lists, maps"}]}]},{"ID":"20240423170424-7kc5a8z","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-7kc5a8z","updated":"20240423170424"},"Children":[{"ID":"20240423170424-j77xbff","Type":"NodeParagraph","Properties":{"id":"20240423170424-j77xbff","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Method invocation"}]}]},{"ID":"20240423170424-hypjrb9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-hypjrb9","updated":"20240423170424"},"Children":[{"ID":"20240423170424-b5vu2p7","Type":"NodeParagraph","Properties":{"id":"20240423170424-b5vu2p7","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Relational operators"}]}]},{"ID":"20240423170424-53exy9b","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-53exy9b","updated":"20240423170424"},"Children":[{"ID":"20240423170424-fxq5usu","Type":"NodeParagraph","Properties":{"id":"20240423170424-fxq5usu","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Assignment"}]}]},{"ID":"20240423170424-b0uj863","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-b0uj863","updated":"20240423170424"},"Children":[{"ID":"20240423170424-ef37sod","Type":"NodeParagraph","Properties":{"id":"20240423170424-ef37sod","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Calling constructors"}]}]},{"ID":"20240423170424-5am3oof","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-5am3oof","updated":"20240423170424"},"Children":[{"ID":"20240423170424-w8qscwj","Type":"NodeParagraph","Properties":{"id":"20240423170424-w8qscwj","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Bean references"}]}]},{"ID":"20240423170424-yr0iztg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-yr0iztg","updated":"20240423170424"},"Children":[{"ID":"20240423170424-z36bh9c","Type":"NodeParagraph","Properties":{"id":"20240423170424-z36bh9c","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Array construction"}]}]},{"ID":"20240423170424-1zq8s4d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-1zq8s4d","updated":"20240423170424"},"Children":[{"ID":"20240423170424-b9xyux3","Type":"NodeParagraph","Properties":{"id":"20240423170424-b9xyux3","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Inline lists"}]}]},{"ID":"20240423170424-h3d67zo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-h3d67zo","updated":"20240423170424"},"Children":[{"ID":"20240423170424-5zjp4er","Type":"NodeParagraph","Properties":{"id":"20240423170424-5zjp4er","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Ternary operator"}]}]},{"ID":"20240423170424-u62hy9m","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-u62hy9m","updated":"20240423170424"},"Children":[{"ID":"20240423170424-vfw5083","Type":"NodeParagraph","Properties":{"id":"20240423170424-vfw5083","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Variables"}]}]},{"ID":"20240423170424-821k5z6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-821k5z6","updated":"20240423170424"},"Children":[{"ID":"20240423170424-i0nou6m","Type":"NodeParagraph","Properties":{"id":"20240423170424-i0nou6m","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"User defined functions"}]}]},{"ID":"20240423170424-r1ekipz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-r1ekipz","updated":"20240423170424"},"Children":[{"ID":"20240423170424-reefroc","Type":"NodeParagraph","Properties":{"id":"20240423170424-reefroc","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Collection projection"}]}]},{"ID":"20240423170424-jksu9ac","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-jksu9ac","updated":"20240423170424"},"Children":[{"ID":"20240423170424-gc4q090","Type":"NodeParagraph","Properties":{"id":"20240423170424-gc4q090","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Collection selection"}]}]},{"ID":"20240423170424-bpnnxp3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423170424-bpnnxp3","updated":"20240423170424"},"Children":[{"ID":"20240423170424-ovx9etq","Type":"NodeParagraph","Properties":{"id":"20240423170424-ovx9etq","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"Templated expressions"}]}]}]},{"ID":"20240423170424-764r65q","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240423170424-764r65q","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"8.3 Expression Evaluation using Spring's Expression Interface"}]},{"ID":"20240423170424-ycuw7cc","Type":"NodeParagraph","Properties":{"id":"20240423170424-ycuw7cc","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"This section introduces the simple use of SpEL interfaces and its expression language. The complete language reference can be found in the section "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-language-ref","TextMarkATitle":"8.5 Language Reference","TextMarkTextContent":"Language Reference"},{"Type":"NodeText","Data":"."}]},{"ID":"20240423170424-j9p76vb","Type":"NodeParagraph","Properties":{"id":"20240423170424-j9p76vb","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The following code introduces the SpEL API to evaluate the literal string expression 'Hello World'."}]},{"ID":"20240423170424-e1n1l50","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-e1n1l50","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"ExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"'Hello World'\");\nString message = (String) exp.getValue();\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-u7xeqiu","Type":"NodeParagraph","Properties":{"id":"20240423170424-u7xeqiu","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The value of the message variable is simply 'Hello World'."}]},{"ID":"20240423170424-mpl39rl","Type":"NodeParagraph","Properties":{"id":"20240423170424-mpl39rl","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The SpEL classes and interfaces you are most likely to use are located in the packages "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"org.springframework.expression"},{"Type":"NodeText","Data":" and its sub packages and "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"spel.support"},{"Type":"NodeText","Data":"."}]},{"ID":"20240423170424-le50gg5","Type":"NodeParagraph","Properties":{"id":"20240423170424-le50gg5","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The interface "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ExpressionParser"},{"Type":"NodeText","Data":"​ is responsible for parsing an expression string. In this example the expression string is a string literal denoted by the surrounding single quotes. The interface "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Expression"},{"Type":"NodeText","Data":"​ is responsible for evaluating the previously defined expression string. There are two exceptions that can be thrown, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ParseException"},{"Type":"NodeText","Data":"​ and "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"EvaluationException"},{"Type":"NodeText","Data":"​ when calling '"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"parser.parseExpression"},{"Type":"NodeText","Data":"​' and '"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"exp.getValue"},{"Type":"NodeText","Data":"​' respectively."}]},{"ID":"20240423170424-xjh8opv","Type":"NodeParagraph","Properties":{"id":"20240423170424-xjh8opv","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"SpEL supports a wide range of features, such as calling methods, accessing properties, and calling constructors."}]},{"ID":"20240423170424-9bz2ick","Type":"NodeParagraph","Properties":{"id":"20240423170424-9bz2ick","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"As an example of method invocation, we call the 'concat' method on the string literal."}]},{"ID":"20240423170424-ogb72gw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-ogb72gw","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"ExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"'Hello World'.concat('!')\");\nString message = (String) exp.getValue();\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-y80vmwy","Type":"NodeParagraph","Properties":{"id":"20240423170424-y80vmwy","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The value of message is now 'Hello World!'."}]},{"ID":"20240423170424-borljzq","Type":"NodeParagraph","Properties":{"id":"20240423170424-borljzq","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"As an example of calling a JavaBean property, the String property 'Bytes' can be called as shown below."}]},{"ID":"20240423170424-u9hbyix","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-u9hbyix","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"ExpressionParser parser = new SpelExpressionParser();\n\n// invokes 'getBytes()'\nExpression exp = parser.parseExpression(\"'Hello World'.bytes\");\n\nbyte[] bytes = (byte[]) exp.getValue();\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-0qofsgc","Type":"NodeParagraph","Properties":{"id":"20240423170424-0qofsgc","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"SpEL also supports nested properties using standard 'dot' notation, i.e. prop1.prop2.prop3 and the setting of property values"}]},{"ID":"20240423170424-fty2osu","Type":"NodeParagraph","Properties":{"id":"20240423170424-fty2osu","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Public fields may also be accessed."}]},{"ID":"20240423170424-yagcdpy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-yagcdpy","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"ExpressionParser parser = new SpelExpressionParser();\n\n// invokes 'getBytes().length'\nExpression exp = parser.parseExpression(\"'Hello World'.bytes.length\");\n\nint length = (Integer) exp.getValue();\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-48g3ex8","Type":"NodeParagraph","Properties":{"id":"20240423170424-48g3ex8","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The String's constructor can be called instead of using a string literal."}]},{"ID":"20240423170424-u0uet8e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-u0uet8e","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"ExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"new String('hello world').toUpperCase()\");\nString message = exp.getValue(String.class);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-k8ujhaf","Type":"NodeParagraph","Properties":{"id":"20240423170424-k8ujhaf","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Note the use of the generic method "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"public \u0026lt;T\u0026gt; T getValue(Class\u0026lt;T\u0026gt; desiredResultType)"},{"Type":"NodeText","Data":"​. Using this method removes the need to cast the value of the expression to the desired result type. An "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"EvaluationException"},{"Type":"NodeText","Data":"​ will be thrown if the value cannot be cast to the type "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ or converted using the registered type converter."}]},{"ID":"20240423170424-rqxjrfz","Type":"NodeParagraph","Properties":{"id":"20240423170424-rqxjrfz","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The more common usage of SpEL is to provide an expression string that is evaluated against a specific object instance (called the root object). There are two options here and which to choose depends on whether the object against which the expression is being evaluated will be changing with each call to evaluate the expression. In the following example we retrieve the "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"name"},{"Type":"NodeText","Data":"​ property from an instance of the Inventor class."}]},{"ID":"20240423170424-9wtfoi5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-9wtfoi5","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// Create and set a calendar\nGregorianCalendar c = new GregorianCalendar();\nc.set(1856, 7, 9);\n\n//  The constructor arguments are name, birthday, and nationality.\nInventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");\n\nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"name\");\nEvaluationContext context = new StandardEvaluationContext(tesla);\n\nString name = (String) exp.getValue(context);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-3a8v7ej","Type":"NodeParagraph","Properties":{"id":"20240423170424-3a8v7ej","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"In the last line, the value of the string variable 'name' will be set to \"Nikola Tesla\". The class StandardEvaluationContext is where you can specify which object the \"name\" property will be evaluated against. This is the mechanism to use if the root object is unlikely to change, it can simply be set once in the evaluation context. If the root object is likely to change repeatedly, it can be supplied on each call to "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getValue"},{"Type":"NodeText","Data":"​, as this next example shows:"}]},{"ID":"20240423170424-h51h0pf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-h51h0pf","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"/ Create and set a calendar\nGregorianCalendar c = new GregorianCalendar();\nc.set(1856, 7, 9);\n\n//  The constructor arguments are name, birthday, and nationality.\nInventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");\n\nExpressionParser parser = new SpelExpressionParser();\nExpression exp = parser.parseExpression(\"name\");\n\nString name = (String) exp.getValue(tesla);\n  \n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-ixkitho","Type":"NodeParagraph","Properties":{"id":"20240423170424-ixkitho","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"In this case the inventor "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"tesla"},{"Type":"NodeText","Data":"​ has been supplied directly to "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getValue"},{"Type":"NodeText","Data":"​ and the expression evaluation infrastructure creates and manages a default evaluation context internally - it did not require one to be supplied."}]},{"ID":"20240423170424-vm01mdv","Type":"NodeParagraph","Properties":{"id":"20240423170424-vm01mdv","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The StandardEvaluationContext is relatively expensive to construct and during repeated usage it builds up cached state that enables subsequent expression evaluations to be performed more quickly. For this reason it is better to cache and reuse them where possible, rather than construct a new one for each expression evaluation."}]},{"ID":"20240423170424-3h7wt9j","Type":"NodeParagraph","Properties":{"id":"20240423170424-3h7wt9j","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"In some cases it can be desirable to use a configured evaluation context and yet still supply a different root object on each call to "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getValue"},{"Type":"NodeText","Data":"​. "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getValue"},{"Type":"NodeText","Data":"​ allows both to be specified on the same call. In these situations the root object passed on the call is considered to override any (which maybe null) specified on the evaluation context."}]},{"ID":"20240423170424-1mtvd8x","Type":"NodeTable","TableAligns":[2],"Properties":{"colgroup":"","id":"20240423170424-1mtvd8x","updated":"20240423170425"},"Children":[{"Type":"NodeTableHead","Data":"thead","Children":[{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"th","TableCellAlign":2,"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"[Note]"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/images/note.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":2,"Children":[{"Type":"NodeText","Data":"In standalone usage of SpEL there is a need to create the parser, parse expressions and perhaps provide evaluation contexts and a root context object. However, more common usage is to provide only the SpEL expression string as part of a configuration file, for example for Spring bean or Spring Web Flow definitions. In this case, the parser, evaluation context, root object and any predefined variables are all set up implicitly, requiring the user to specify nothing other than the expressions."}]}]}]},{"ID":"20240423170424-7i3e7n7","Type":"NodeParagraph","Properties":{"id":"20240423170424-7i3e7n7","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"As a final introductory example, the use of a boolean operator is shown using the Inventor object in the previous example."}]},{"ID":"20240423170424-j5mm40l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-j5mm40l","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"Expression exp = parser.parseExpression(\"name == 'Nikola Tesla'\");\nboolean result = exp.getValue(context, Boolean.class);  // evaluates to true\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-mlwzshs","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-mlwzshs","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.3.1 The EvaluationContext interface"}]},{"ID":"20240423170424-clbk3e8","Type":"NodeParagraph","Properties":{"id":"20240423170424-clbk3e8","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The interface "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"EvaluationContext"},{"Type":"NodeText","Data":"​ is used when evaluating an expression to resolve properties, methods, fields, and to help perform type conversion. The out-of-the-box implementation, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"StandardEvaluationContext"},{"Type":"NodeText","Data":"​, uses reflection to manipulate the object, caching "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"java.lang.reflect"},{"Type":"NodeText","Data":"'s "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Method"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Field"},{"Type":"NodeText","Data":"​, and "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Constructor"},{"Type":"NodeText","Data":"​ instances for increased performance."}]},{"ID":"20240423170424-3smbxco","Type":"NodeParagraph","Properties":{"id":"20240423170424-3smbxco","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"StandardEvaluationContext"},{"Type":"NodeText","Data":"​ is where you may specify the root object to evaluate against via the method "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"setRootObject()"},{"Type":"NodeText","Data":"​ or passing the root object into the constructor. You can also specify variables and functions that will be used in the expression using the methods "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"setVariable()"},{"Type":"NodeText","Data":"​ and "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"registerFunction()"},{"Type":"NodeText","Data":"​. The use of variables and functions are described in the language reference sections "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-ref-variables","TextMarkATitle":"8.5.10 Variables","TextMarkTextContent":"Variables"},{"Type":"NodeText","Data":" and "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-ref-functions","TextMarkATitle":"8.5.11 Functions","TextMarkTextContent":"Functions"},{"Type":"NodeText","Data":". The "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"StandardEvaluationContext"},{"Type":"NodeText","Data":"​ is also where you can register custom "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ConstructorResolver"},{"Type":"NodeText","Data":"​s, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MethodResolver"},{"Type":"NodeText","Data":"​s, and "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"PropertyAccessor"},{"Type":"NodeText","Data":"​s to extend how SpEL evaluates expressions. Please refer to the JavaDoc of these classes for more details."}]},{"ID":"20240423170424-j4kt6zw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240423170424-j4kt6zw","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Type Conversion"}]},{"ID":"20240423170424-vmtjl7k","Type":"NodeParagraph","Properties":{"id":"20240423170424-vmtjl7k","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"By default SpEL uses the conversion service available in Spring core ("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"org.springframework.core.convert.ConversionService"},{"Type":"NodeText","Data":"​). This conversion service comes with many converters built in for common conversions but is also fully extensible so custom conversions between types can be added. Additionally it has the key capability that it is generics aware. This means that when working with generic types in expressions, SpEL will attempt conversions to maintain type correctness for any objects it encounters."}]},{"ID":"20240423170424-g89rqdt","Type":"NodeParagraph","Properties":{"id":"20240423170424-g89rqdt","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"What does this mean in practice? Suppose assignment, using "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"setValue()"},{"Type":"NodeText","Data":"​, is being used to set a "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"List"},{"Type":"NodeText","Data":"​ property. The type of the property is actually "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"List\u0026lt;Boolean\u0026gt;"},{"Type":"NodeText","Data":"​. SpEL will recognize that the elements of the list need to be converted to "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Boolean"},{"Type":"NodeText","Data":"​ before being placed in it. A simple example:"}]},{"ID":"20240423170424-v910l1q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-v910l1q","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"class Simple {\n    public List\u003cBoolean\u003e booleanList = new ArrayList\u003cBoolean\u003e();\n}\n\nSimple simple = new Simple();\n\nsimple.booleanList.add(true);\n\nStandardEvaluationContext simpleContext = new StandardEvaluationContext(simple);\n\n// false is passed in here as a string.  SpEL and the conversion service will\n// correctly recognize that it needs to be a Boolean and convert it\nparser.parseExpression(\"booleanList[0]\").setValue(simpleContext, \"false\");\n\n// b will be false\nBoolean b = simple.booleanList.get(0);\n    \n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-qxo8xcd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240423170424-qxo8xcd","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"8.4 Expression support for defining bean definitions"}]},{"ID":"20240423170424-krdbhgt","Type":"NodeParagraph","Properties":{"id":"20240423170424-krdbhgt","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"SpEL expressions can be used with XML or annotation based configuration metadata for defining BeanDefinitions. In both cases the syntax to define the expression is of the form "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"#{ \u0026lt;expression string\u0026gt; }"},{"Type":"NodeText","Data":"​."}]},{"ID":"20240423170424-j2hpzme","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-j2hpzme","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.4.1 XML based configuration"}]},{"ID":"20240423170424-z0fhtne","Type":"NodeParagraph","Properties":{"id":"20240423170424-z0fhtne","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"A property or constructor-arg value can be set using expressions as shown below"}]},{"ID":"20240423170424-194jhn6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-194jhn6","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"\u003cbean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\"\u003e\n    \u003cproperty name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/\u003e\n\n    \u003c!-- other properties --\u003e\n\u003c/bean\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-n6d9nbp","Type":"NodeParagraph","Properties":{"id":"20240423170424-n6d9nbp","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The variable 'systemProperties' is predefined, so you can use it in your expressions as shown below. Note that you do not have to prefix the predefined variable with the '#' symbol in this context."}]},{"ID":"20240423170424-j9epbt0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-j9epbt0","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"\u003cbean id=\"taxCalculator\" class=\"org.spring.samples.TaxCalculator\"\u003e\n    \u003cproperty name=\"defaultLocale\" value=\"#{ systemProperties['user.region'] }\"/\u003e\n\n    \u003c!-- other properties --\u003e\n\u003c/bean\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-5aa1ff5","Type":"NodeParagraph","Properties":{"id":"20240423170424-5aa1ff5","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"You can also refer to other bean properties by name, for example."}]},{"ID":"20240423170424-o1mhyz9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-o1mhyz9","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"\u003cbean id=\"numberGuess\" class=\"org.spring.samples.NumberGuess\"\u003e\n    \u003cproperty name=\"randomNumber\" value=\"#{ T(java.lang.Math).random() * 100.0 }\"/\u003e\n\n    \u003c!-- other properties --\u003e\n\u003c/bean\u003e\n\n\n\u003cbean id=\"shapeGuess\" class=\"org.spring.samples.ShapeGuess\"\u003e\n    \u003cproperty name=\"initialShapeSeed\" value=\"#{ numberGuess.randomNumber }\"/\u003e\n\n    \u003c!-- other properties --\u003e\n\u003c/bean\u003e\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-h3nhfcy","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-h3nhfcy","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.4.2 Annotation-based configuration"}]},{"ID":"20240423170424-in68pq1","Type":"NodeParagraph","Properties":{"id":"20240423170424-in68pq1","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"@Value"},{"Type":"NodeText","Data":"​ annotation can be placed on fields, methods and method/constructor parameters to specify a default value."}]},{"ID":"20240423170424-90dzs7l","Type":"NodeParagraph","Properties":{"id":"20240423170424-90dzs7l","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Here is an example to set the default value of a field variable."}]},{"ID":"20240423170424-0q6275d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-0q6275d","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"public static class FieldValueTestBean\n\n  @Value(\"#{ systemProperties['user.region'] }\")\n  private String defaultLocale;\n\n  public void setDefaultLocale(String defaultLocale)\n  {\n    this.defaultLocale = defaultLocale;\n  }\n\n  public String getDefaultLocale()\n  {\n    return this.defaultLocale;\n  }\n\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-4x6vt4n","Type":"NodeParagraph","Properties":{"id":"20240423170424-4x6vt4n","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The equivalent but on a property setter method is shown below."}]},{"ID":"20240423170424-rm9f36j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-rm9f36j","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"public static class PropertyValueTestBean\n\n  private String defaultLocale;\n\n  @Value(\"#{ systemProperties['user.region'] }\")\n  public void setDefaultLocale(String defaultLocale)\n  {\n    this.defaultLocale = defaultLocale;\n  }\n\n  public String getDefaultLocale()\n  {\n    return this.defaultLocale;\n  }\n\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-ylfgdj9","Type":"NodeParagraph","Properties":{"id":"20240423170424-ylfgdj9","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Autowired methods and constructors can also use the "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"@Value"},{"Type":"NodeText","Data":"​ annotation."}]},{"ID":"20240423170424-9xcf4f4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-9xcf4f4","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"public class SimpleMovieLister {\n\n  private MovieFinder movieFinder;\n  private String defaultLocale;\n\n  @Autowired\n  public void configure(MovieFinder movieFinder,\n                        @Value(\"#{ systemProperties['user.region'] }\") String defaultLocale) {\n      this.movieFinder = movieFinder;\n      this.defaultLocale = defaultLocale;\n  }\n\n  // ...\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-m4ts192","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-m4ts192","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"public class MovieRecommender {\n\n  private String defaultLocale;\n\n  private CustomerPreferenceDao customerPreferenceDao;\n\n  @Autowired\n  public MovieRecommender(CustomerPreferenceDao customerPreferenceDao,\n                          @Value(\"#{systemProperties['user.country']}\") String defaultLocale) {\n      this.customerPreferenceDao = customerPreferenceDao;\n      this.defaultLocale = defaultLocale;\n  }\n\n  // ...\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-20psjyo","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240423170424-20psjyo","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"8.5 Language Reference"}]},{"ID":"20240423170424-38fkxz4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-38fkxz4","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.1 Literal expressions"}]},{"ID":"20240423170424-7th9m1z","Type":"NodeParagraph","Properties":{"id":"20240423170424-7th9m1z","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The types of literal expressions supported are strings, numeric values (int, real, hex), boolean and null. Strings are delimited by single quotes. To put a single quote itself in a string, use two single quote characters. The following listing shows simple usage of literals. Typically they would not be used in isolation like this but rather as part of a more complex expression, for example using a literal on one side of a logical comparison operator."}]},{"ID":"20240423170424-zbs9vqx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-zbs9vqx","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"ExpressionParser parser = new SpelExpressionParser();\n\n// evals to \"Hello World\"\nString helloWorld = (String) parser.parseExpression(\"'Hello World'\").getValue();\n\ndouble avogadrosNumber  = (Double) parser.parseExpression(\"6.0221415E+23\").getValue();\n\n// evals to 2147483647\nint maxValue = (Integer) parser.parseExpression(\"0x7FFFFFFF\").getValue();\n\nboolean trueValue = (Boolean) parser.parseExpression(\"true\").getValue();\n\nObject nullValue = parser.parseExpression(\"null\").getValue();\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-83wyu8b","Type":"NodeParagraph","Properties":{"id":"20240423170424-83wyu8b","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Numbers support the use of the negative sign, exponential notation, and decimal points. By default real numbers are parsed using Double.parseDouble()."}]},{"ID":"20240423170424-o31ptbi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-o31ptbi","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.2 Properties, Arrays, Lists, Maps, Indexers"}]},{"ID":"20240423170424-trdnah3","Type":"NodeParagraph","Properties":{"id":"20240423170424-trdnah3","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Navigating with property references is easy, just use a period to indicate a nested property value. The instances of Inventor class, pupin and tesla, were populated with data listed in the section "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-example-classes","TextMarkATitle":"8.6 Classes used in the examples","TextMarkTextContent":"Classes used in the examples"},{"Type":"NodeText","Data":". To navigate \"down\" and get Tesla's year of birth and Pupin's city of birth the following expressions are used."}]},{"ID":"20240423170424-kjg0ain","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-kjg0ain","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// evals to 1856\nint year = (Integer) parser.parseExpression(\"Birthdate.Year + 1900\").getValue(context);\n\n\nString city = (String) parser.parseExpression(\"placeOfBirth.City\").getValue(context);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-8fcsy8x","Type":"NodeParagraph","Properties":{"id":"20240423170424-8fcsy8x","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Case insensitivity is allowed for the first letter of property names. The contents of arrays and lists are obtained using square bracket notation."}]},{"ID":"20240423170424-956ziqv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-956ziqv","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"ExpressionParser parser = new SpelExpressionParser();\n\n// Inventions Array\nStandardEvaluationContext teslaContext = new StandardEvaluationContext(tesla);\n\n// evaluates to \"Induction motor\"\nString invention = parser.parseExpression(\"inventions[3]\").getValue(teslaContext,\n                                                                    String.class);\n\n\n// Members List\nStandardEvaluationContext societyContext = new StandardEvaluationContext(ieee);\n\n// evaluates to \"Nikola Tesla\"\nString name = parser.parseExpression(\"Members[0].Name\").getValue(societyContext, String.class);\n\n// List and Array navigation\n// evaluates to \"Wireless communication\"\nString invention = parser.parseExpression(\"Members[0].Inventions[6]\").getValue(societyContext,\n                                                                               String.class);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-m56ozlv","Type":"NodeParagraph","Properties":{"id":"20240423170424-m56ozlv","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The contents of maps are obtained by specifying the literal key value within the brackets. In this case, because keys for the Officers map are strings, we can specify string literals."}]},{"ID":"20240423170424-6yao5w7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-6yao5w7","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// Officer's Dictionary\n\nInventor pupin = parser.parseExpression(\"Officers['president']\").getValue(societyContext,\n                                                                          Inventor.class);\n\n// evaluates to \"Idvor\"\nString city =\n    parser.parseExpression(\"Officers['president'].PlaceOfBirth.City\").getValue(societyContext,\n                                                                               String.class);\n\n// setting values\nparser.parseExpression(\"Officers['advisors'][0].PlaceOfBirth.Country\").setValue(societyContext,\n                                                                                \"Croatia\");\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-cdhk5wr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-cdhk5wr","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.3 Inline lists"}]},{"ID":"20240423170424-3cw6ejh","Type":"NodeParagraph","Properties":{"id":"20240423170424-3cw6ejh","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Lists can be expressed directly in an expression using {} notation."}]},{"ID":"20240423170424-jhncyr7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-jhncyr7","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// evaluates to a Java list containing the four numbers\nList numbers = (List) parser.parseExpression(\"{1,2,3,4}\").getValue(context);\n\nList listOfLists = (List) parser.parseExpression(\"{{'a','b'},{'x','y'}}\").getValue(context);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-2n6sor4","Type":"NodeParagraph","Properties":{"id":"20240423170424-2n6sor4","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"{} by itself means an empty list. For performance reasons, if the list is itself entirely composed of fixed literals then a constant list is created to represent the expression, rather than building a new list on each evaluation."}]},{"ID":"20240423170424-qcmw7u6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-qcmw7u6","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.4 Array construction"}]},{"ID":"20240423170424-03wvei8","Type":"NodeParagraph","Properties":{"id":"20240423170424-03wvei8","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Arrays can be built using the familiar Java syntax, optionally supplying an initializer to have the array populated at construction time."}]},{"ID":"20240423170424-xhmyqqr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-xhmyqqr","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"int[] numbers1 = (int[]) parser.parseExpression(\"new int[4]\").getValue(context);\n\n// Array with initializer\nint[] numbers2 = (int[]) parser.parseExpression(\"new int[]{1,2,3}\").getValue(context);\n\n// Multi dimensional array\nint[][] numbers3 = (int[][]) parser.parseExpression(\"new int[4][5]\").getValue(context);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-k3zac27","Type":"NodeParagraph","Properties":{"id":"20240423170424-k3zac27","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"It is not currently allowed to supply an initializer when constructing a multi-dimensional array."}]},{"ID":"20240423170424-8wj663m","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-8wj663m","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.5 Methods"}]},{"ID":"20240423170424-bywnby0","Type":"NodeParagraph","Properties":{"id":"20240423170424-bywnby0","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Methods are invoked using typical Java programming syntax. You may also invoke methods on literals. Varargs are also supported."}]},{"ID":"20240423170424-13etilf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-13etilf","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// string literal, evaluates to \"bc\"\nString c = parser.parseExpression(\"'abc'.substring(2, 3)\").getValue(String.class);\n\n// evaluates to true\nboolean isMember = parser.parseExpression(\"isMember('Mihajlo Pupin')\").getValue(societyContext, Boolean.class);\n  \n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-szg4j9t","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-szg4j9t","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.6 Operators"}]},{"ID":"20240423170424-fjhjis7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240423170424-fjhjis7","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Relational operators"}]},{"ID":"20240423170424-ebrzjp5","Type":"NodeParagraph","Properties":{"id":"20240423170424-ebrzjp5","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The relational operators; equal, not equal, less than, less than or equal, greater than, and greater than or equal are supported using standard operator notation."}]},{"ID":"20240423170424-qaywxmv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-qaywxmv","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// evaluates to true\nboolean trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean.class);\n\n// evaluates to false\nboolean falseValue = parser.parseExpression(\"2 \u003c -5.0\").getValue(Boolean.class);\n\n// evaluates to true\nboolean trueValue = parser.parseExpression(\"'black' \u003c 'block'\").getValue(Boolean.class);\n    \n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-9op9svl","Type":"NodeParagraph","Properties":{"id":"20240423170424-9op9svl","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Greater/less-than comparisons against "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":"​ follow a simple rule: "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":"​ is treated as nothing here (i.e. NOT as zero). As a consequence, any other value is always greater than "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":"​ ("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"X \u0026gt; null"},{"Type":"NodeText","Data":"​ is always "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"​) and no other value is ever less than nothing ("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"X \u0026lt; null"},{"Type":"NodeText","Data":"​ is always "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"​). If you prefer numeric comparisons instead, please avoid number-based "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":"​ comparisons in favor of comparisons against zero (e.g. "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"X \u0026gt; 0"},{"Type":"NodeText","Data":"​ or "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"X \u0026lt; 0"},{"Type":"NodeText","Data":"​)."}]},{"ID":"20240423170424-smhz9ov","Type":"NodeParagraph","Properties":{"id":"20240423170424-smhz9ov","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"In addition to standard relational operators SpEL supports the 'instanceof' and regular expression based 'matches' operator."}]},{"ID":"20240423170424-ifmerxu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-ifmerxu","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// evaluates to false\nboolean falseValue = parser.parseExpression(\"'xyz' instanceof T(int)\").getValue(Boolean.class);\n\n// evaluates to true\nboolean trueValue =\n     parser.parseExpression(\"'5.00' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n\n//evaluates to false\nboolean falseValue =\n     parser.parseExpression(\"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n    \n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-1olbyz1","Type":"NodeParagraph","Properties":{"id":"20240423170424-1olbyz1","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Each symbolic operator can also be specified as a purely alphabetic equivalent. This avoids problems where the symbols used have special meaning for the document type in which the expression is embedded (eg. an XML document). The textual equivalents are shown here: lt ('\u003c'), gt ('\u003e'), le ('\u003c='), ge ('\u003e='), eq ('=='), ne ('!='), div ('/'), mod ('%'), not ('!'). These are case insensitive."}]},{"ID":"20240423170424-t3c7wkn","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240423170424-t3c7wkn","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Logical operators"}]},{"ID":"20240423170424-d0hz9lh","Type":"NodeParagraph","Properties":{"id":"20240423170424-d0hz9lh","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The logical operators that are supported are and, or, and not. Their use is demonstrated below."}]},{"ID":"20240423170424-uo3x4av","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-uo3x4av","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// -- AND --\n\n// evaluates to false\nboolean falseValue = parser.parseExpression(\"true and false\").getValue(Boolean.class);\n\n// evaluates to true\nString expression =  \"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\";\nboolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n\n// -- OR --\n\n// evaluates to true\nboolean trueValue = parser.parseExpression(\"true or false\").getValue(Boolean.class);\n\n// evaluates to true\nString expression =  \"isMember('Nikola Tesla') or isMember('Albert Einstein')\";\nboolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n\n// -- NOT --\n\n// evaluates to false\nboolean falseValue = parser.parseExpression(\"!true\").getValue(Boolean.class);\n\n\n// -- AND and NOT --\nString expression =  \"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\";\nboolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-ojjdbe3","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240423170424-ojjdbe3","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Mathematical operators"}]},{"ID":"20240423170424-n06h4rb","Type":"NodeParagraph","Properties":{"id":"20240423170424-n06h4rb","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The addition operator can be used on numbers, strings and dates. Subtraction can be used on numbers and dates. Multiplication and division can be used only on numbers. Other mathematical operators supported are modulus (%) and exponential power (^). Standard operator precedence is enforced. These operators are demonstrated below."}]},{"ID":"20240423170424-bc7bjjm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-bc7bjjm","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// Addition\nint two = parser.parseExpression(\"1 + 1\").getValue(Integer.class); // 2\n\nString testString =\n   parser.parseExpression(\"'test' + ' ' + 'string'\").getValue(String.class);  // 'test string'\n\n// Subtraction\nint four =  parser.parseExpression(\"1 - -3\").getValue(Integer.class); // 4\n\ndouble d = parser.parseExpression(\"1000.00 - 1e4\").getValue(Double.class); // -9000\n\n// Multiplication\nint six =  parser.parseExpression(\"-2 * -3\").getValue(Integer.class); // 6\n\ndouble twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(Double.class); // 24.0\n\n// Division\nint minusTwo =  parser.parseExpression(\"6 / -3\").getValue(Integer.class); // -2\n\ndouble one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(Double.class); // 1.0\n\n// Modulus\nint three =  parser.parseExpression(\"7 % 4\").getValue(Integer.class); // 3\n\nint one = parser.parseExpression(\"8 / 5 % 2\").getValue(Integer.class); // 1\n\n// Operator precedence\nint minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(Integer.class); // -21\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-dhtop7k","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-dhtop7k","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.7 Assignment"}]},{"ID":"20240423170424-xetps1m","Type":"NodeParagraph","Properties":{"id":"20240423170424-xetps1m","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Setting of a property is done by using the assignment operator. This would typically be done within a call to "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"setValue"},{"Type":"NodeText","Data":"​ but can also be done inside a call to "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"getValue"},{"Type":"NodeText","Data":"​."}]},{"ID":"20240423170424-y6vfu2e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-y6vfu2e","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"Inventor inventor = new Inventor();\nStandardEvaluationContext inventorContext = new StandardEvaluationContext(inventor);\n\nparser.parseExpression(\"Name\").setValue(inventorContext, \"Alexander Seovic2\");\n\n// alternatively\n\nString aleks = parser.parseExpression(\"Name = 'Alexandar Seovic'\").getValue(inventorContext,\n                                                                            String.class);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-a79zifl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-a79zifl","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.8 Types"}]},{"ID":"20240423170424-xmqbcfl","Type":"NodeParagraph","Properties":{"id":"20240423170424-xmqbcfl","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The special 'T' operator can be used to specify an instance of java.lang.Class (the 'type'). Static methods are invoked using this operator as well. The "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"StandardEvaluationContext"},{"Type":"NodeText","Data":"​ uses a "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TypeLocator"},{"Type":"NodeText","Data":"​ to find types and the "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"StandardTypeLocator"},{"Type":"NodeText","Data":"​ (which can be replaced) is built with an understanding of the java.lang package. This means T() references to types within java.lang do not need to be fully qualified, but all other type references must be."}]},{"ID":"20240423170424-gplghvc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-gplghvc","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"Class dateClass = parser.parseExpression(\"T(java.util.Date)\").getValue(Class.class);\n\nClass stringClass = parser.parseExpression(\"T(String)\").getValue(Class.class);\n\nboolean trueValue =\n   parser.parseExpression(\"T(java.math.RoundingMode).CEILING \u003c T(java.math.RoundingMode).FLOOR\")\n  .getValue(Boolean.class);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-z490ypp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-z490ypp","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.9 Constructors"}]},{"ID":"20240423170424-meqv9vx","Type":"NodeParagraph","Properties":{"id":"20240423170424-meqv9vx","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Constructors can be invoked using the new operator. The fully qualified class name should be used for all but the primitive type and String (where int, float, etc, can be used)."}]},{"ID":"20240423170424-181bd8j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-181bd8j","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"Inventor einstein =\n  p.parseExpression(\"new org.spring.samples.spel.inventor.Inventor('Albert Einstein',\n                                                                   'German')\")\n                                                                   .getValue(Inventor.class);\n\n//create new inventor instance within add method of List\np.parseExpression(\"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein',\n                                                                   'German'))\")\n                                                                   .getValue(societyContext);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-z5encnn","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-z5encnn","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.10 Variables"}]},{"ID":"20240423170424-w87bzxd","Type":"NodeParagraph","Properties":{"id":"20240423170424-w87bzxd","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Variables can be referenced in the expression using the syntax #variableName. Variables are set using the method setVariable on the StandardEvaluationContext."}]},{"ID":"20240423170424-f89e60a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-f89e60a","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"Inventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\ncontext.setVariable(\"newName\", \"Mike Tesla\");\n\nparser.parseExpression(\"Name = #newName\").getValue(context);\n\nSystem.out.println(tesla.getName()) // \"Mike Tesla\"\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-9erce51","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20240423170424-9erce51","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The #this and #root variables"}]},{"ID":"20240423170424-qi93q65","Type":"NodeParagraph","Properties":{"id":"20240423170424-qi93q65","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The variable #this is always defined and refers to the current evaluation object (against which unqualified references are resolved). The variable #root is always defined and refers to the root context object. Although #this may vary as components of an expression are evaluated, #root always refers to the root."}]},{"ID":"20240423170424-w350bd7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-w350bd7","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// create an array of integers\nList\u003cInteger\u003e primes = new ArrayList\u003cInteger\u003e();\nprimes.addAll(Arrays.asList(2,3,5,7,11,13,17));\n\n// create parser and set variable 'primes' as the array of integers\nExpressionParser parser = new SpelExpressionParser();\nStandardEvaluationContext context = new StandardEvaluationContext();\ncontext.setVariable(\"primes\",primes);\n\n// all prime numbers \u003e 10 from the list (using selection ?{...})\n// evaluates to [11, 13, 17]\nList\u003cInteger\u003e primesGreaterThanTen =\n             (List\u003cInteger\u003e) parser.parseExpression(\"#primes.?[#this\u003e10]\").getValue(context);\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-q1es3i3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-q1es3i3","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.11 Functions"}]},{"ID":"20240423170424-33i191n","Type":"NodeParagraph","Properties":{"id":"20240423170424-33i191n","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"You can extend SpEL by registering user defined functions that can be called within the expression string. The function is registered with the "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"StandardEvaluationContext"},{"Type":"NodeText","Data":"​ using the method."}]},{"ID":"20240423170424-184dxyz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-184dxyz","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"public void registerFunction(String name, Method m)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-yjtbd39","Type":"NodeParagraph","Properties":{"id":"20240423170424-yjtbd39","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"A reference to a Java Method provides the implementation of the function. For example, a utility method to reverse a string is shown below."}]},{"ID":"20240423170424-abwjs4k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-abwjs4k","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"public abstract class StringUtils {\n\n  public static String reverseString(String input) {\n    StringBuilder backwards = new StringBuilder();\n    for (int i = 0; i \u003c input.length(); i++)\n      backwards.append(input.charAt(input.length() - 1 - i));\n    }\n    return backwards.toString();\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-39e1s0z","Type":"NodeParagraph","Properties":{"id":"20240423170424-39e1s0z","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"This method is then registered with the evaluation context and can be used within an expression string."}]},{"ID":"20240423170424-x6zq1uj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-x6zq1uj","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"ExpressionParser parser = new SpelExpressionParser();\nStandardEvaluationContext context = new StandardEvaluationContext();\n\ncontext.registerFunction(\"reverseString\",\n                         StringUtils.class.getDeclaredMethod(\"reverseString\",\n                                                             new Class[] { String.class }));\n\nString helloWorldReversed =\n          parser.parseExpression(\"#reverseString('hello')\").getValue(context, String.class);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-8imk90a","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-8imk90a","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.12 Bean references"}]},{"ID":"20240423170424-l3ugpob","Type":"NodeParagraph","Properties":{"id":"20240423170424-l3ugpob","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"If the evaluation context has been configured with a bean resolver it is possible to lookup beans from an expression using the (@) symbol."}]},{"ID":"20240423170424-ufo0ueq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-ufo0ueq","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"ExpressionParser parser = new SpelExpressionParser();\nStandardEvaluationContext context = new StandardEvaluationContext();\ncontext.setBeanResolver(new MyBeanResolver());\n\n// This will end up calling resolve(context,\"foo\") on MyBeanResolver during evaluation\nObject bean = parser.parseExpression(\"@foo\").getValue(context);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-f5er2s4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-f5er2s4","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.13 Ternary Operator (If-Then-Else)"}]},{"ID":"20240423170424-waqohlp","Type":"NodeParagraph","Properties":{"id":"20240423170424-waqohlp","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"You can use the ternary operator for performing if-then-else conditional logic inside the expression. A minimal example is:"}]},{"ID":"20240423170424-qdf1yeg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-qdf1yeg","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"String falseString =\n             parser.parseExpression(\"false ? 'trueExp' : 'falseExp'\").getValue(String.class);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-1ta1k78","Type":"NodeParagraph","Properties":{"id":"20240423170424-1ta1k78","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"In this case, the boolean false results in returning the string value 'falseExp'. A more realistic example is shown below."}]},{"ID":"20240423170424-tx0722k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-tx0722k","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"parser.parseExpression(\"Name\").setValue(societyContext, \"IEEE\");\nsocietyContext.setVariable(\"queryName\", \"Nikola Tesla\");\n\nexpression = \"isMember(#queryName)? #queryName + ' is a member of the ' \" +\n             \"+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'\";\n\nString queryResultString =\n                    parser.parseExpression(expression).getValue(societyContext, String.class);\n// queryResultString = \"Nikola Tesla is a member of the IEEE Society\"\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-r4xi9pb","Type":"NodeParagraph","Properties":{"id":"20240423170424-r4xi9pb","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Also see the next section on the Elvis operator for an even shorter syntax for the ternary operator."}]},{"ID":"20240423170424-a6d68ti","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-a6d68ti","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.14 The Elvis Operator"}]},{"ID":"20240423170424-fmpe29y","Type":"NodeParagraph","Properties":{"id":"20240423170424-fmpe29y","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The Elvis operator is a shortening of the ternary operator syntax and is used in the "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"http://groovy.codehaus.org/Operators#Operators-ElvisOperator(%3F%3A)","TextMarkTextContent":"Groovy"},{"Type":"NodeText","Data":" language. With the ternary operator syntax you usually have to repeat a variable twice, for example:"}]},{"ID":"20240423170424-d50uvaf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-d50uvaf","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"String name = \"Elvis Presley\";\nString displayName = name != null ? name : \"Unknown\";\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-kfncuao","Type":"NodeParagraph","Properties":{"id":"20240423170424-kfncuao","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Instead you can use the Elvis operator, named for the resemblance to Elvis' hair style."}]},{"ID":"20240423170424-gv2b82v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-gv2b82v","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"ExpressionParser parser = new SpelExpressionParser();\n\nString name = parser.parseExpression(\"null?:'Unknown'\").getValue(String.class);\n\nSystem.out.println(name);  // 'Unknown'\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-ztqr88f","Type":"NodeParagraph","Properties":{"id":"20240423170424-ztqr88f","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Here is a more complex example."}]},{"ID":"20240423170424-qz0jk0q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-qz0jk0q","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"ExpressionParser parser = new SpelExpressionParser();\n\nInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\n\nString name = parser.parseExpression(\"Name?:'Elvis Presley'\").getValue(context, String.class);\n\nSystem.out.println(name); // Nikola Tesla\n\ntesla.setName(null);\n\nname = parser.parseExpression(\"Name?:'Elvis Presley'\").getValue(context, String.class);\n\nSystem.out.println(name); // Elvis Presley\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-vs8b9f3","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-vs8b9f3","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.15 Safe Navigation operator"}]},{"ID":"20240423170424-t8zu0mb","Type":"NodeParagraph","Properties":{"id":"20240423170424-t8zu0mb","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The Safe Navigation operator is used to avoid a "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NullPointerException"},{"Type":"NodeText","Data":"​ and comes from the "},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"http://groovy.codehaus.org/Operators#Operators-SafeNavigationOperator(%3F.)","TextMarkTextContent":"Groovy"},{"Type":"NodeText","Data":" language. Typically when you have a reference to an object you might need to verify that it is not null before accessing methods or properties of the object. To avoid this, the safe navigation operator will simply return null instead of throwing an exception."}]},{"ID":"20240423170424-plxv8ov","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-plxv8ov","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"ExpressionParser parser = new SpelExpressionParser();\n\nInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\ntesla.setPlaceOfBirth(new PlaceOfBirth(\"Smiljan\"));\n\nStandardEvaluationContext context = new StandardEvaluationContext(tesla);\n\nString city = parser.parseExpression(\"PlaceOfBirth?.City\").getValue(context, String.class);\nSystem.out.println(city); // Smiljan\n\ntesla.setPlaceOfBirth(null);\n\ncity = parser.parseExpression(\"PlaceOfBirth?.City\").getValue(context, String.class);\n\nSystem.out.println(city); // null - does not throw NullPointerException!!!\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-rdhhzrr","Type":"NodeTable","TableAligns":[2],"Properties":{"colgroup":"","id":"20240423170424-rdhhzrr","updated":"20240423170425"},"Children":[{"Type":"NodeTableHead","Data":"thead","Children":[{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"th","TableCellAlign":2,"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"[Note]"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/images/note.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":2,"Children":[{"Type":"NodeText","Data":"The Elvis operator can be used to apply default values in expressions, e.g. in an "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"@Value"},{"Type":"NodeText","Data":"​ expression:"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"@Value(\u0026quot;#{systemProperties['pop3.port'] ?: 25}\u0026quot;)"},{"Type":"NodeText","Data":"​This will inject a system property "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pop3.port"},{"Type":"NodeText","Data":"​ if it is defined or 25 if not."}]}]}]},{"ID":"20240423170424-ml5vqeb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-ml5vqeb","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.16 Collection Selection"}]},{"ID":"20240423170424-0rppnmi","Type":"NodeParagraph","Properties":{"id":"20240423170424-0rppnmi","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Selection is a powerful expression language feature that allows you to transform some source collection into another by selecting from its entries."}]},{"ID":"20240423170424-dizb0pz","Type":"NodeParagraph","Properties":{"id":"20240423170424-dizb0pz","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Selection uses the syntax "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"?[selectionExpression]"},{"Type":"NodeText","Data":"​. This will filter the collection and return a new collection containing a subset of the original elements. For example, selection would allow us to easily get a list of Serbian inventors:"}]},{"ID":"20240423170424-bp8vcni","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-bp8vcni","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"List\u003cInventor\u003e list = (List\u003cInventor\u003e)\n      parser.parseExpression(\"Members.?[Nationality == 'Serbian']\").getValue(societyContext);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-mkkrzk9","Type":"NodeParagraph","Properties":{"id":"20240423170424-mkkrzk9","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Selection is possible upon both lists and maps. In the former case the selection criteria is evaluated against each individual list element whilst against a map the selection criteria is evaluated against each map entry (objects of the Java type "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Map.Entry"},{"Type":"NodeText","Data":"​). Map entries have their key and value accessible as properties for use in the selection."}]},{"ID":"20240423170424-melksnn","Type":"NodeParagraph","Properties":{"id":"20240423170424-melksnn","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"This expression will return a new map consisting of those elements of the original map where the entry value is less than 27."}]},{"ID":"20240423170424-ir9870h","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-ir9870h","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"Map newMap = parser.parseExpression(\"map.?[value\u003c27]\").getValue();\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-w6er7q3","Type":"NodeParagraph","Properties":{"id":"20240423170424-w6er7q3","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"In addition to returning all the selected elements, it is possible to retrieve just the first or the last value. To obtain the first entry matching the selection the syntax is "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"^[...]"},{"Type":"NodeText","Data":"​ whilst to obtain the last matching selection the syntax is "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"$[...]"},{"Type":"NodeText","Data":"​."}]},{"ID":"20240423170424-b6zi1t9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-b6zi1t9","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.17 Collection Projection"}]},{"ID":"20240423170424-e4eh83l","Type":"NodeParagraph","Properties":{"id":"20240423170424-e4eh83l","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Projection allows a collection to drive the evaluation of a sub-expression and the result is a new collection. The syntax for projection is "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"![projectionExpression]"},{"Type":"NodeText","Data":"​. Most easily understood by example, suppose we have a list of inventors but want the list of cities where they were born. Effectively we want to evaluate 'placeOfBirth.city' for every entry in the inventor list. Using projection:"}]},{"ID":"20240423170424-di1uvcn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-di1uvcn","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"// returns [ 'Smiljan', 'Idvor' ]\nList placesOfBirth = (List)parser.parseExpression(\"Members.![placeOfBirth.city]\");\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-f2rhfbg","Type":"NodeParagraph","Properties":{"id":"20240423170424-f2rhfbg","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"A map can also be used to drive projection and in this case the projection expression is evaluated against each entry in the map (represented as a Java "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Map.Entry"},{"Type":"NodeText","Data":"​). The result of a projection across a map is a list consisting of the evaluation of the projection expression against each map entry."}]},{"ID":"20240423170424-t5yr4dw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423170424-t5yr4dw","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"8.5.18 Expression templating"}]},{"ID":"20240423170424-ajh2h1l","Type":"NodeParagraph","Properties":{"id":"20240423170424-ajh2h1l","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Expression templates allow a mixing of literal text with one or more evaluation blocks. Each evaluation block is delimited with prefix and suffix characters that you can define, a common choice is to use "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"#{ }"},{"Type":"NodeText","Data":"​ as the delimiters. For example,"}]},{"ID":"20240423170424-41kl79p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-41kl79p","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"String randomPhrase =\n   parser.parseExpression(\"random number is #{T(java.lang.Math).random()}\",\n                          new TemplateParserContext()).getValue(String.class);\n\n// evaluates to \"random number is 0.7038186818312008\"\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-kpuj61f","Type":"NodeParagraph","Properties":{"id":"20240423170424-kpuj61f","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"The string is evaluated by concatenating the literal text 'random number is ' with the result of evaluating the expression inside the #{ } delimiter, in this case the result of calling that random() method. The second argument to the method "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"parseExpression()"},{"Type":"NodeText","Data":"​ is of the type "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ParserContext"},{"Type":"NodeText","Data":"​. The "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ParserContext"},{"Type":"NodeText","Data":"​ interface is used to influence how the expression is parsed in order to support the expression templating functionality. The definition of "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"TemplateParserContext"},{"Type":"NodeText","Data":"​ is shown below."}]},{"ID":"20240423170424-ta0igjw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-ta0igjw","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"public class TemplateParserContext implements ParserContext {\n\n  public String getExpressionPrefix() {\n    return \"#{\";\n  }\n\n  public String getExpressionSuffix() {\n    return \"}\";\n  }\n\n  public boolean isTemplate() {\n    return true;\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-0enidda","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240423170424-0enidda","updated":"20240423170424"},"Children":[{"Type":"NodeText","Data":"8.6 Classes used in the examples"}]},{"ID":"20240423170424-tkp1367","Type":"NodeParagraph","Properties":{"id":"20240423170424-tkp1367","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Inventor.java"}]},{"ID":"20240423170424-ody76ju","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-ody76ju","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"package org.spring.samples.spel.inventor;\n\nimport java.util.Date;\nimport java.util.GregorianCalendar;\n\npublic class Inventor {\n\n  private String name;\n  private String nationality;\n  private String[] inventions;\n  private Date birthdate;\n  private PlaceOfBirth placeOfBirth;\n\n\n  public Inventor(String name, String nationality)\n  {\n    GregorianCalendar c= new GregorianCalendar();\n    this.name = name;\n    this.nationality = nationality;\n    this.birthdate = c.getTime();\n  }\n  public Inventor(String name, Date birthdate, String nationality) {\n    this.name = name;\n    this.nationality = nationality;\n    this.birthdate = birthdate;\n  }\n\n  public Inventor() {\n  }\n\n  public String getName() {\n    return name;\n  }\n  public void setName(String name) {\n    this.name = name;\n  }\n  public String getNationality() {\n    return nationality;\n  }\n  public void setNationality(String nationality) {\n    this.nationality = nationality;\n  }\n  public Date getBirthdate() {\n    return birthdate;\n  }\n  public void setBirthdate(Date birthdate) {\n    this.birthdate = birthdate;\n  }\n  public PlaceOfBirth getPlaceOfBirth() {\n    return placeOfBirth;\n  }\n  public void setPlaceOfBirth(PlaceOfBirth placeOfBirth) {\n    this.placeOfBirth = placeOfBirth;\n  }\n  public void setInventions(String[] inventions) {\n    this.inventions = inventions;\n  }\n  public String[] getInventions() {\n    return inventions;\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-st636he","Type":"NodeParagraph","Properties":{"id":"20240423170424-st636he","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"PlaceOfBirth.java"}]},{"ID":"20240423170424-grsahnd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-grsahnd","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"package org.spring.samples.spel.inventor;\n\npublic class PlaceOfBirth {\n\n    private String city;\n    private String country;\n\n    public PlaceOfBirth(String city) {\n        this.city=city;\n    }\n    public PlaceOfBirth(String city, String country)\n    {\n        this(city);\n        this.country = country;\n    }\n\n\n    public String getCity() {\n        return city;\n    }\n    public void setCity(String s) {\n        this.city = s;\n    }\n    public String getCountry() {\n        return country;\n    }\n    public void setCountry(String country) {\n        this.country = country;\n    }\n\n\n\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240423170424-8ni9fli","Type":"NodeParagraph","Properties":{"id":"20240423170424-8ni9fli","updated":"20240423170425"},"Children":[{"Type":"NodeText","Data":"Society.java"}]},{"ID":"20240423170424-tt4ls28","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240423170424-tt4ls28","updated":"20240423170425"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"package org.spring.samples.spel.inventor;\n\nimport java.util.*;\n\npublic class Society {\n\n    private String name;\n\n    public static String Advisors = \"advisors\";\n    public static String President = \"president\";\n\n    private List\u003cInventor\u003e members = new ArrayList\u003cInventor\u003e();\n    private Map officers = new HashMap();\n\n    public List getMembers() {\n        return members;\n    }\n\n    public Map getOfficers() {\n        return officers;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public boolean isMember(String name)\n    {\n        boolean found = false;\n        for (Inventor inventor : members) {\n            if (inventor.getName().equals(name))\n            {\n                found = true;\n                break;\n            }\n        }\n        return found;\n    }\n\n\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}