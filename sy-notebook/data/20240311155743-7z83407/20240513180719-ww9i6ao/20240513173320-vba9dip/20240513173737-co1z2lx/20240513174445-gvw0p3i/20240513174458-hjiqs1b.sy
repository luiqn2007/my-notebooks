{"ID":"20240513174458-hjiqs1b","Spec":"1","Type":"NodeDocument","Properties":{"icon":"minecraft.ico","id":"20240513174458-hjiqs1b","title":"函子 Functor","type":"doc","updated":"20240513174628"},"Children":[{"ID":"20240513174508-wjdmkz4","Type":"NodeParagraph","Properties":{"id":"20240513174508-wjdmkz4","updated":"20240513174508"},"Children":[{"Type":"NodeText","Data":"函子 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Functor"},{"Type":"NodeText","Data":"​ 是一种实现 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​ 函数的容器。这允许我们在不解开容器的情况下操作容器中的值。"}]},{"ID":"20240513174542-qn4z1as","Type":"NodeSuperBlock","Properties":{"id":"20240513174542-qn4z1as","updated":"20240513174543"},"Children":[{"Type":"NodeSuperBlockOpenMarker"},{"Type":"NodeSuperBlockLayoutMarker","Data":"col"},{"ID":"20240513174508-ypvx4ua","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240513174508-ypvx4ua","updated":"20240513174543"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"// 容器\ninterface Container\u003cA\u003e {}\n// 函子\ninterface Functor\u003cA\u003e extends Container\u003cA\u003e {\n    \u003cB\u003e Functor\u003cB\u003e map(Function\u003cA, B\u003e f);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240513174508-jxzttyx","Type":"NodeParagraph","Properties":{"id":"20240513174508-jxzttyx","updated":"20240513174543"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"Pasted image 20231022233403"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/Pasted image 20231022233403-20240513174540-hviqjut.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"Type":"NodeSuperBlockCloseMarker"}]},{"ID":"20240513174508-2cplmp3","Type":"NodeParagraph","Properties":{"id":"20240513174508-2cplmp3","updated":"20240513174508"},"Children":[{"Type":"NodeText","Data":"在范畴学中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"functor"},{"Type":"NodeText","Data":"​ 接受一个范畴的对象和态射（"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"morphism"},{"Type":"NodeText","Data":"​），然后把它们映射（"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"map"},{"Type":"NodeText","Data":"​）到另一个范畴里去。根据定义，这个新范畴一定会有一个单位元（"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"identity"},{"Type":"NodeText","Data":"​），也一定能够组合态射；我们无须验证这一点，前面提到的定律保证这些东西会在映射后得到保留。"}]},{"ID":"20240513174508-9sihs0c","Type":"NodeList","ListData":{},"Properties":{"id":"20240513174508-9sihs0c","updated":"20240513174508"},"Children":[{"ID":"20240513174508-uzlims1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240513174508-uzlims1","updated":"20240513174508"},"Children":[{"ID":"20240513174508-cc6g5im","Type":"NodeParagraph","Properties":{"id":"20240513174508-cc6g5im","updated":"20240513174508"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"functor"},{"Type":"NodeText","Data":"​ 相当于图中的 F，即容器；"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"F a"},{"Type":"NodeText","Data":"​ 表示函子中存放有 a 数据"}]}]},{"ID":"20240513174508-svmaw36","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240513174508-svmaw36","updated":"20240513174508"},"Children":[{"ID":"20240513174508-ri3r11p","Type":"NodeParagraph","Properties":{"id":"20240513174508-ri3r11p","updated":"20240513174508"},"Children":[{"Type":"NodeText","Data":"态射相当于图中的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"f"},{"Type":"NodeText","Data":"​；单位元即 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"id"},{"Type":"NodeText","Data":"​ 函数"}]}]}]},{"ID":"20240513174508-owpikgd","Type":"NodeParagraph","Properties":{"id":"20240513174508-owpikgd","updated":"20240513174508"},"Children":[{"Type":"NodeText","Data":"可以把范畴想象成一个有着多个对象的网络，对象之间靠态射连接。那么 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"functor"},{"Type":"NodeText","Data":"​ 可以把一个范畴映射到另外一个，而且不会破坏原有的网络。如果一个对象 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"a"},{"Type":"NodeText","Data":"​ 属于源范畴 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"C"},{"Type":"NodeText","Data":"​，那么通过 functor "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"F"},{"Type":"NodeText","Data":"​ 把 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"a"},{"Type":"NodeText","Data":"​ 映射到目标范畴 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"D"},{"Type":"NodeText","Data":"​ 上之后，就可以使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"F a"},{"Type":"NodeText","Data":"​ 来指代 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"a"},{"Type":"NodeText","Data":"​ 对象。"}]},{"ID":"20240513174628-vk4i8jl","Type":"NodeParagraph","Properties":{"id":"20240513174628-vk4i8jl","updated":"20240513174628"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"Pasted image 20231022234931"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/Pasted image 20231022234931-20240513174628-uwni9rh.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}