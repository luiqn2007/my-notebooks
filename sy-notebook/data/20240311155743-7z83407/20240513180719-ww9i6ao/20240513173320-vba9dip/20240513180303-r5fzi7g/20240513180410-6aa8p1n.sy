{"ID":"20240513180410-6aa8p1n","Spec":"1","Type":"NodeDocument","Properties":{"icon":"minecraft.ico","id":"20240513180410-6aa8p1n","title":"App 与 K","type":"doc","updated":"20240513180422"},"Children":[{"ID":"20240513180422-4ts8o6s","Type":"NodeParagraph","Properties":{"id":"20240513180422-4ts8o6s","updated":"20240513180422"},"Children":[{"Type":"NodeText","Data":"DFU 中实际数据都是存在在一个个容器中的，App 和 App2 即容器的接口，该接口规定了两个泛型 F 和 A(与B)，没有任何需要实现的成员"}]},{"ID":"20240513180422-gthm5p7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240513180422-gthm5p7","updated":"20240513180422"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"public interface App\u003cF extends K1, A\u003e {}\npublic interface App2\u003cF extends K2, A, B\u003e {}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240513180422-4hkcwon","Type":"NodeParagraph","Properties":{"id":"20240513180422-4hkcwon","updated":"20240513180422"},"Children":[{"Type":"NodeText","Data":"两个泛型中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"F"},{"Type":"NodeText","Data":"​ 表示容器类型，每个容器中都有一个特定实现的空类型用于区分实际容器类型。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"A"},{"Type":"NodeText","Data":"​/"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"B"},{"Type":"NodeText","Data":"​ 则表示容器中数据的类型。"}]},{"ID":"20240513180422-2ga97jw","Type":"NodeParagraph","Properties":{"id":"20240513180422-2ga97jw","updated":"20240513180422"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"F"},{"Type":"NodeText","Data":"​ 继承自 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"K1"},{"Type":"NodeText","Data":"​ 或 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"K2"},{"Type":"NodeText","Data":"​。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"K1"},{"Type":"NodeText","Data":"​ 对应 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"App"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"K2"},{"Type":"NodeText","Data":"​ 对应 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"App2"},{"Type":"NodeText","Data":"​，用于在模糊化容器类型后还能重新找回容器类型 - 每个容器都有一个属于自己的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mu"},{"Type":"NodeText","Data":"​ 类，该类继承自 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"K1"},{"Type":"NodeText","Data":"​ 或 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"K2"},{"Type":"NodeText","Data":"​，可以代表该类型并通过对应类型的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unbox"},{"Type":"NodeText","Data":"​ 方法找回自己的类型。"}]},{"ID":"20240513180422-5oxhaas","Type":"NodeParagraph","Properties":{"id":"20240513180422-5oxhaas","updated":"20240513180422"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"K1"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"K2"},{"Type":"NodeText","Data":"​ 中的 1 或 2 表示数据运算时，每次算子运算的数据个数，而后面的 A B 则表示每个运算数的类型。大多数容器类都只存储一类数据，因此都是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"App1"},{"Type":"NodeText","Data":"​。而 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Pair"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Either"},{"Type":"NodeText","Data":"​ 类由于每次只处理一个数据，也是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"App1"},{"Type":"NodeText","Data":"​ 类型。"}]}]}