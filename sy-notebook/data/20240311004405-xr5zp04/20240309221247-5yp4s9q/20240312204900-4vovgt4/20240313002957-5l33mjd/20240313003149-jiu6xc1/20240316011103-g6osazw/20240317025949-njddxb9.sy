{"ID":"20240317025949-njddxb9","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f630","id":"20240317025949-njddxb9","title":"lambda 原表达式理","updated":"20240317033413"},"Children":[{"ID":"20240317025949-x1oq6lk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240317025949-x1oq6lk","updated":"20240317030351"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"public static void main(String[] args) {\n    Runnable r = () -\u003e {\n        System.out.println(\"Hello lambda\");\n    };\n    r.run();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240317030354-j74n8yn","Type":"NodeParagraph","Properties":{"id":"20240317030354-j74n8yn","updated":"20240317031545"},"Children":[{"Type":"NodeText","Data":"编译后可见："}]},{"ID":"20240317030523-ov8io1x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240317030523-ov8io1x","updated":"20240317031536"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"public static void main(java.lang.String[]):\n  invokedynamic   #7, 0  // InvokeDynamic #0: run: ()Ljava/lang/Runnable\n  astore_1\n  aload_1\n  invokeinterface #11, 1 // InterfaceMethod: java/lang/Runnable.run:()V\n  return\nprivate static void lambda$main$0():\n  getstatic     #15 // Field java/lang/System.out:Ljava/io/PrintStream;\n  ldc           #21 // String Hello lambda\n  invokevirtual #23 // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n  return\nBootstrapMethods:\n  0: #46 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n    Method arguments:\n      #53 ()V\n      #54 REF_invokeStatic org/example/Main.lambda$main$0:()V\n      #53 ()V\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240317031250-91tpk9f","Type":"NodeParagraph","Properties":{"id":"20240317031250-91tpk9f","updated":"20240317031815"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Main"},{"Type":"NodeText","Data":"​ 类中生成了一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"lambda$main$0"},{"Type":"NodeText","Data":"​ 方法，该方法即 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"lambda"},{"Type":"NodeText","Data":"​ 的代码。该函数的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"BootstrapMethod"},{"Type":"NodeText","Data":"​ 表示为："}]},{"ID":"20240317031816-fxa6p32","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240317031816-fxa6p32","updated":"20240317032912"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker"},{"Type":"NodeCodeBlockCode","Data":"public static CallSite metafactory(\n    Lookup caller,                       // 调用者，用于查找方法的上下文\n    String invokedName,                  // 调用函数名 = \"run\"\n    MethodType invokedType,\n    MethodType samMethodType,            // 函数式接口定义的方法 = ()void\n    MethodHandle implMethod,             // 编译时生成的静态方法 = lambda$main$0\n    MethodType instantiatedMethodType    // 一般与 samMethodType 相同或为其特例 = ()void\n);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240317032912-oob4auv","Type":"NodeParagraph","Properties":{"id":"20240317032912-oob4auv","updated":"20240317032934"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"java.lang.invoke.LambdaMetafactory"},{"Type":"NodeText","Data":"​ 中可以看到 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"metafactory"},{"Type":"NodeText","Data":"​ 的源码："}]},{"ID":"20240317032934-bjdwpof","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240317032934-bjdwpof","updated":"20240317033051"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"public static CallSite metafactory(MethodHandles.Lookup caller,\n                                   String interfaceMethodName,\n                                   MethodType factoryType,\n                                   MethodType interfaceMethodType,\n                                   MethodHandle implementation,\n                                   MethodType dynamicMethodType)\n        throws LambdaConversionException {\n    AbstractValidatingLambdaMetafactory mf;\n    mf = new InnerClassLambdaMetafactory(caller, factoryType, interfaceMethodName, \n                                         interfaceMethodType, implementation, dynamicMethodType, \n                                         false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);\n    mf.validateMetafactoryArgs();\n    return mf.buildCallSite();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240317033144-6fmme3h","Type":"NodeParagraph","Properties":{"id":"20240317033144-6fmme3h","updated":"20240317033413"},"Children":[{"Type":"NodeText","Data":"而在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"InnerClassLambdaMetafactory"},{"Type":"NodeText","Data":"​ 中，使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ASM"},{"Type":"NodeText","Data":"​ 生成内部类："}]},{"ID":"20240317033253-0x99y3b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240317033253-0x99y3b","updated":"20240317033319"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"implMethodClassName = implClass.getName().replace('.', '/');\nimplMethodName = implInfo.getName();\nimplMethodDesc = implInfo.getMethodType().toMethodDescriptorString();\nconstructorType = factoryType.changeReturnType(Void.TYPE);\nlambdaClassName = lambdaClassName(targetClass);\n// If the target class invokes a protected method inherited from a\n// superclass in a different package, or does 'invokespecial', the\n// lambda class has no access to the resolved method. Instead, we need\n// to pass the live implementation method handle to the proxy class\n// to invoke directly. (javac prefers to avoid this situation by\n// generating bridges in the target class)\nuseImplMethodHandle = (Modifier.isProtected(implInfo.getModifiers()) \u0026\u0026\n                       !VerifyAccess.isSamePackage(targetClass, implInfo.getDeclaringClass())) ||\n                       implKind == H_INVOKESPECIAL;\ncw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\nint parameterCount = factoryType.parameterCount();\nif (parameterCount \u003e 0) {\n    argNames = new String[parameterCount];\n    argDescs = new String[parameterCount];\n    for (int i = 0; i \u003c parameterCount; i++) {\n        argNames[i] = \"arg$\" + (i + 1);\n        argDescs[i] = BytecodeDescriptor.unparse(factoryType.parameterType(i));\n    }\n} else {\n    argNames = argDescs = EMPTY_STRING_ARRAY;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}