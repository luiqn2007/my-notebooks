{"ID":"20240409220959-en74nvh","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f980","id":"20240409220959-en74nvh","title":"共享内存与锁","type":"doc","updated":"20240411233422"},"Children":[{"ID":"20240409221006-xqd2jqm","Type":"NodeParagraph","Properties":{"id":"20240409221006-xqd2jqm","updated":"20240409221006"},"Children":[{"Type":"NodeText","Data":"虽然 Rust 不推荐直接共享内存来共享数据，但还是提供了锁来保证共享内存的安全性。"}]},{"ID":"20240409221006-q141l1n","Type":"NodeParagraph","Properties":{"id":"20240409221006-q141l1n","updated":"20240409221006"},"Children":[{"Type":"NodeText","Data":"互斥器 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​ 是一把锁，用于保证同一时刻只允许一个线程访问数据。线程通过获取互斥器的锁来访问数据，锁记录了谁有数据的排他性访问权。"}]},{"ID":"20240409221014-86od414","Type":"NodeParagraph","Properties":{"id":"20240409221014-86od414","updated":"20240409221014"},"Children":[{"Type":"NodeText","Data":"通常使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Arc\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​ 创建智能指针引用。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Arc\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​ 相当于线程安全的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rc\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​, 有着相同的 API"}]},{"ID":"20240409221006-2r2zu03","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240409221006-2r2zu03","updated":"20240409221008"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cnVzdA=="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let m = Mutex::new(0);\n    let counter = Arc::new(m);\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = counter.clone();\n        let handle = thread::spawn(move || {\n            // Mutex 具有内部可变性\n            *counter.lock().unwrap() += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // Result=10\n    println!(\"Result={}\", counter.lock().unwrap())\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240411002404-b9wr2ek","Type":"NodeParagraph","Properties":{"id":"20240411002404-b9wr2ek","updated":"20240411002746"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Cow"},{"Type":"NodeText","Data":"​ 智能指针也用于共享内存。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Cow"},{"Type":"NodeText","Data":"​ 是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Copy-On-Write"},{"Type":"NodeText","Data":"​ 的缩写。当数据将被修改时，Rust 会将原数据复制一份并在复制出的这份数据上修改，保证了读数据时的数据一致性。"}]},{"ID":"20240411233422-ku3kcho","Type":"NodeParagraph","Properties":{"id":"20240411233422-ku3kcho"}}]}