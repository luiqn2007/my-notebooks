{"ID":"20240310164621-s03rwum","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f1e8","id":"20240310164621-s03rwum","title":"互斥量与锁","type":"doc","updated":"20240503155508"},"Children":[{"ID":"20240310164630-6y16poo","Type":"NodeParagraph","Properties":{"id":"20240310164630-6y16poo","updated":"20240310164630"},"Children":[{"Type":"NodeText","Data":"互斥量位于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::mutex"},{"Type":"NodeText","Data":"​，是一种用于线程同步的手段，保存共享数据"}]},{"ID":"20240310164630-hy1klw3","Type":"NodeList","ListData":{},"Properties":{"id":"20240310164630-hy1klw3","updated":"20240310164630"},"Children":[{"ID":"20240310164630-uis2ike","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240310164630-uis2ike","updated":"20240310164630"},"Children":[{"ID":"20240310164630-2t1xfes","Type":"NodeParagraph","Properties":{"id":"20240310164630-2t1xfes","updated":"20240310164630"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::mutex"},{"Type":"NodeText","Data":"​：独占的互斥量，无法递归使用，不带超时功能"}]}]},{"ID":"20240310164630-brit1v4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240310164630-brit1v4","updated":"20240310164630"},"Children":[{"ID":"20240310164630-sjccykn","Type":"NodeParagraph","Properties":{"id":"20240310164630-sjccykn","updated":"20240310164630"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::recursive_mutex"},{"Type":"NodeText","Data":"​：递归互斥量，可重入，不带超时功能"}]}]},{"ID":"20240310164630-80ndcf5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240310164630-80ndcf5","updated":"20240310164630"},"Children":[{"ID":"20240310164630-4hvy8zd","Type":"NodeParagraph","Properties":{"id":"20240310164630-4hvy8zd","updated":"20240310164630"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::timed_mutex"},{"Type":"NodeText","Data":"​：带超时的互斥量，不能递归使用"}]}]},{"ID":"20240310164630-7qnu54m","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240310164630-7qnu54m","updated":"20240310164630"},"Children":[{"ID":"20240310164630-3tw1i2x","Type":"NodeParagraph","Properties":{"id":"20240310164630-3tw1i2x","updated":"20240310164630"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::recursive_timed_mutex"},{"Type":"NodeText","Data":"​：带超时的可递归互斥量"}]}]}]},{"ID":"20240310164630-cah987o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310164630-cah987o","updated":"20240503155444"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"int main() {\n    mutex m;\n\n    auto func = [\u0026](const string\u0026 name, int k) {\n        m.lock();\n        cout \u003c\u003c \"Running: \" \u003c\u003c name \u003c\u003c \" \";\n        for (int i = 0; i \u003c k; ++i) {\n            cout \u003c\u003c i \u003c\u003c \" \";\n        }\n        cout \u003c\u003c endl;\n        m.unlock();\n    };\n\n    thread threads[5];\n    for (int i = 0; i \u003c 5; ++i) {\n        string name {\"Thread \"};\n        name.append(to_string(i)).push_back('-');\n        threads[i] = thread(func, name, 10);\n    }\n\n/*\n线程依次有序执行，共享资源（m）限制线程执行\n\nRunning: Thread 0- 0 1 2 3 4 5 6 7 8 9\nRunning: Thread 1- 0 1 2 3 4 5 6 7 8 9\nRunning: Thread 2- 0 1 2 3 4 5 6 7 8 9\nRunning: Thread 3- 0 1 2 3 4 5 6 7 8 9\nRunning: Thread 4- 0 1 2 3 4 5 6 7 8 9\n*/\n    for (auto \u0026item: threads) {\n        item.join();\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240503155433-cc707p4","Type":"NodeParagraph","Properties":{"id":"20240503155433-cc707p4","updated":"20240503155433"},"Children":[{"Type":"NodeText","Data":"锁配合互斥量使用，位于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock"},{"Type":"NodeText","Data":"​ 。动态释放锁资源，防止线程由于编码失误导致无法释放锁，主要有 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock_guard"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeText","Data":"​ 两种模式"}]},{"ID":"20240503155433-dcgr1ss","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240503155433-dcgr1ss","updated":"20240503155433"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"// ...\nauto func = [\u0026](const string\u0026 name, int k) {\n    unique_lock\u003cmutex\u003e lock(m);\n    // ...\n};\n// ...\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240503155433-i29ncop","Type":"NodeParagraph","Properties":{"id":"20240503155433-i29ncop","updated":"20240503155433"},"Children":[{"Type":"NodeText","Data":"仅将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m.lock();"},{"Type":"NodeText","Data":"​ 修改为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unique_lock\u0026lt;mutex\u0026gt; lock(m);"},{"Type":"NodeText","Data":"​，移除 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m.unlock"},{"Type":"NodeText","Data":"​ 即可，线程会自动在执行完成后释放锁。"}]},{"ID":"20240503155433-lz3mnht","Type":"NodeParagraph","Properties":{"id":"20240503155433-lz3mnht","updated":"20240503155433"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock_guard"},{"Type":"NodeText","Data":"​ 更加轻量级，但 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeText","Data":"​有 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unlock"},{"Type":"NodeText","Data":"​ 函数可用于手动释放锁。"}]}]}